#' draw an oncoplot
#' @description takes output generated by read.maf and draws an oncoplot (aka waterfall plot).
#'
#' @details
#' Takes maf file as input and plots it as a matrix. Any desired annotations can be added at the bottom of the oncoplot by providing \code{annotation}.
#' Oncoplot can be sorted either by mutations or annotations using arguments \code{sortByMutation} and \code{sortByAnnotation} respectively.
#'
#' Thanks to Ryan Morin for \code{sortByAnnotation} code.
#'
#'
#' @param maf an \code{\link{MAF}} object generated by \code{\link{read.maf}}
#' @param top how many top genes to be drawn. defaults to 20.
#' @param genes Just draw oncoplot for these genes. defaults to NULL.
#' @param drawRowBar logical plots barplot for each gene.
#' @param drawColBar logical plots barplot for each sample.
#' @param showTumorSampleBarcodes logical to include sample names.
#' @param annotation data.frame with first column containing Tumor_Sample_Barcodes and rest of columns with annotations.
#' @param genesToIgnore do not show these genes in Oncoplot. Default NULL.
#' @param annotationColor list of colors to use for annotation. Default NULL.
#' @param removeNonMutated Logical. If \code{TRUE} removes samples with no mutations in the oncoplot for better visualization. Default \code{TRUE}.
#' @param colors named vector of colors for each Variant_Classification.
#' @param fontSize font size for gene names. Default 10.
#' @param sortByMutation Helpful in case of MAF was read along with copy number data. Default FALSE.
#' @param sortByAnnotation logical sort oncomatrix by provided annotations. Defaults to FALSE. This is mutually exclusive with sortByMutation.
#' @param writeMatrix writes character coded matrix used to generate the plot to an output file. This can be used as an input
#' for ComplexHeatmap \link[ComplexHeatmap]{oncoPrint} function if you wish to customize the plot.
#' @return None.
#' @examples
#' laml.maf <- system.file("extdata", "tcga_laml.maf.gz", package = "maftools")
#' laml <- read.maf(maf = laml.maf, removeSilent = TRUE, useAll = FALSE)
#' oncoplot(maf = laml, top = 3)
#' @import ComplexHeatmap
#' @import grid
#' @seealso \code{\link{oncostrip}}
#' @export


oncoplot = function (maf, writeMatrix = FALSE, top = 20, genes = NULL, drawRowBar = TRUE, drawColBar = TRUE,
                      showTumorSampleBarcodes = FALSE, annotation = NULL, annotationColor = NULL, genesToIgnore = NULL,
                      removeNonMutated = TRUE, colors = NULL, fontSize = 10, sortByMutation = FALSE, sortByAnnotation = FALSE) {

  #set seed for consistancy.
  set.seed(seed = 1024)

  #-------------------------------------Preprocess matrix---------------------------------------------------

  #numeric matrix and char matrix
  numMat = maf@numericMatrix
  mat_origin = maf@oncoMatrix

  #If <2 samples stop !
  if(ncol(numMat) < 2){
    stop('Cannot create oncoplot for single sample. Minimum two sample required ! ')
  }

  #remove genes from genesToIgnore if any
  if(!is.null(genesToIgnore)){
    numMat = numMat[!rownames(numMat) %in% genesToIgnore,]
    mat_origin = mat_origin[!rownames(mat_origin) %in% genesToIgnore,]
  }

  #If user provides a gene list
  if(!is.null(genes)){

    #Check for any missing genes and ignore them if necessary
    if(length(genes[!genes %in% rownames(numMat)]) > 0){
      message('Following genes are not available in MAF:')
      print(genes[!genes %in% rownames(numMat)])
      message('Ignoring them.')
      genes = genes[genes %in% rownames(numMat)]
    }

    if(length(genes) < 2){
      stop('Provide at least 2 genes.')
    }

    numMat = numMat[genes,, drop = FALSE]
    numMat = sortByMutation(numMat = numMat, maf = maf)
    mat_origin = mat_origin[rownames(numMat), , drop = FALSE]
    mat_origin = mat_origin[,colnames(numMat), drop = FALSE]
    mat = mat_origin
  } else{
    #If user does not provide gene list draw TOP (default 20) genes

    if(sortByAnnotation){
      if(is.null(annotation)){
        stop("Missing annotation data. Use argument `annotation` to provide annotations.")
      }
      numMat = sortByAnnotation(numMat,maf,annotation)
      mat_origin = mat_origin[rownames(numMat),, drop = FALSE]
      mat_origin = mat_origin[,colnames(numMat), drop = FALSE]
    }else{
      if(sortByMutation){
        #This is in case input maf was read with copynumber data but still wants to maintain mutation order (ignoring copynumber variants).
        numMat = sortByMutation(numMat = numMat, maf = maf)
        mat_origin = mat_origin[rownames(numMat),, drop = FALSE]
        mat_origin = mat_origin[,colnames(numMat), drop = FALSE]
      }
    }

    if(nrow(mat_origin) < top){
      mat = mat_origin
    }else{
      mat = mat_origin[1:top, , drop = FALSE]
    }
  }

  #To remove samples with no mutations in top n genes, if user says removeNonMutated
  if(removeNonMutated){
    numMat = numMat[rownames(mat), , drop = FALSE]
    numMat = numMat[,colnames(mat), drop = FALSE]
    tsb = colnames(numMat)
    tsb.exclude = colnames(numMat[,colSums(numMat) == 0, drop = FALSE])
    tsb.include = tsb[!tsb %in% tsb.exclude]
    mat = mat[,tsb.include, drop = FALSE]
  }

  if (writeMatrix) {
    write.table(mat, "onco_matrix.txt", sep = "\t", quote = FALSE)
  }

  #New version of complexheatmap complains about '' , replacing them with random string xxx
  mat[mat == ''] = 'xxx'


  #---------------------------------------Colors and vcs-------------------------------------------------

  #hard coded colors for variant classification if user doesnt provide any
  if(is.null(colors)){
    col = c(RColorBrewer::brewer.pal(12,name = "Paired"), RColorBrewer::brewer.pal(11,name = "Spectral")[1:3],'black', 'violet', 'royalblue')
    names(col) = names = c('Nonstop_Mutation','Frame_Shift_Del','IGR','Missense_Mutation','Silent','Nonsense_Mutation',
                           'RNA','Splice_Site','Intron','Frame_Shift_Ins','Nonstop_Mutation','In_Frame_Del','ITD','In_Frame_Ins',
                           'Translation_Start_Site',"Multi_Hit", 'Amp', 'Del')
  }else{
    col = colors
  }

  bg = "#CCCCCC" #Default gray background
  col = c(col, 'xxx' = bg)

  #Variant classes available in matrix
  variant.classes = unique(unlist(as.list(apply(mat_origin, 2, unique))))
  variant.classes = unique(unlist(strsplit(x = variant.classes, split = ';', fixed = TRUE)))
  variant.classes = variant.classes[!variant.classes %in% c('xxx')]

  type_col = structure(col[variant.classes], names = names(col[variant.classes]))
  type_col = type_col[!is.na(type_col)]

  type_name = structure(variant.classes, names = variant.classes)

  variant.classes = variant.classes[!variant.classes %in% c('Amp', 'Del')]

  #Variant classes available in plot matrix (We want to color code all vc's in colbar but only use those
  #in plot matrix for legend)
  vc.mat = unique(unlist(as.list(apply(mat, 2, unique))))
  vc.mat = unique(unlist(strsplit(x = vc.mat, split = ';', fixed = TRUE)))
  vc.mat = vc.mat[!vc.mat %in% c('xxx')]
  vc.type_name = structure(vc.mat, names = vc.mat)

  vc.type_col = structure(col[vc.mat], names = names(col[vc.mat]))
  vc.type_col = vc.type_col[!is.na(vc.type_col)]

  #annotation if given
  if(!is.null(annotation)){
    annotation[,1] = gsub(pattern = '-', replacement = '.', x = annotation[,1])
    rownames(annotation) = annotation[,1]
    annotation = annotation[colnames(mat_origin),]
    annotation = annotation[complete.cases(annotation),]
    anno.df = data.frame(row.names = annotation[,1])
    anno.df = cbind(anno.df, annotation[,2:ncol(annotation)])
    colnames(anno.df) = colnames(annotation)[2:ncol(annotation)]
    #needed such that the annotation order matches the sample order if any type of sort is used
    if(sortByMutation || sortByAnnotation){
      sorted.order = colnames(mat)
      anno.df.sorted = as.data.frame(anno.df[sorted.order,])
      rownames(anno.df.sorted) = sorted.order
      colnames(anno.df.sorted) = colnames(anno.df)
      anno.df = anno.df.sorted
    }

    if(!is.null(annotationColor)){
      bot.anno = ComplexHeatmap::HeatmapAnnotation(df = anno.df, col = annotationColor)
    }else{
      bot.anno = ComplexHeatmap::HeatmapAnnotation(anno.df)
    }
  }

  #------------------------------------functions to add %, rowbar and colbar----------------------------------------------------

  #------------------------------------------------------------------------------------------------------
  #Many thanks to Zuguang Gu (ComplexHeatmap) for letting me use the below code !
  #Modifed for maftools.
  #------------------------------------------------------------------------------------------------------

  ##This function adds percent rate
  anno_pct = function(index) {
    n = length(index)
    pct = apply(mat_origin[rev(index), ], 1, function(x) sum(!grepl("^\\s*$", x))/length(x)) * 100
    pct = paste0(round(pct), "%")
    grid::pushViewport(viewport(xscale = c(0, 1), yscale = c(0.5, n + 0.5)))
    grid::grid.text(pct, x = 1, y = seq_along(index), default.units = "native",
                    just = "right", gp = grid::gpar(fontsize = fontSize))
    grid::upViewport()
  }

  ha_pct = ComplexHeatmap::HeatmapAnnotation(pct = anno_pct,
                                             width = grid::grobWidth(grid::textGrob("100%", gp = grid::gpar(fontsize = 10))), which = "row")

  ##This function adds rowbar
  anno_row_bar = function(index) {
    n = length(index)

    tb = list()
    for(i in nrow(mat):1){
      x = mat[i,]
      x = x[x != '']
      x = x[x != 'xxx']
      x = unlist(strsplit(x, ";"))
      x = sort(x)
      tb[[i]] = table(x)
    }
    tb = rev(tb)

#     tb = apply(mat[rev(index), ], 1, function(x) {
#       x = unlist(strsplit(x, ";"))
#       #x = x[!grepl("^\\s*$", x)]
#       x = x[!x == '']
#       x = x[!x == 'xxx']
#       x = sort(x)
#       table(x)
#     })
#     print(tb)

    max_count = max(sapply(tb, sum))
    grid::pushViewport(grid::viewport(xscale = c(0, max_count * 1.1), yscale = c(0.5, n + 0.5)))
    for (i in seq_along(tb)) {
      if (length(tb[[i]])) {
        x = cumsum(tb[[i]])
        grid::grid.rect(x = x, i, width = tb[[i]], height = 0.8,
                        default.units = "native", just = "right",
                        gp = grid::gpar(col = NA, fill = type_col[names(tb[[i]])]))
      }
    }
    breaks = grid::grid.pretty(c(0, max_count))
    grid::grid.xaxis(at = breaks, label = breaks, main = FALSE,
                     gp = grid::gpar(fontsize = 10))
    grid::upViewport()
  }

  ha_row_bar = ComplexHeatmap::HeatmapAnnotation(row_bar = anno_row_bar,
                                                 width = grid::unit(4, "cm"), which = "row")

  ##This function adds columnbar
  anno_column_bar = function(index) {
    n = length(index)
    tb = apply(mat_origin[, index], 2, function(x) {
      x = unlist(strsplit(x, ";"))
      x = x[!grepl("^\\s*$", x)]
      x = sort(x)
      table(x)
    })
    max_count = max(sapply(tb, sum))
    grid::pushViewport(grid::viewport(yscale = c(0, max_count * 1.1),
                                      xscale = c(0.5, n + 0.5)))
    for (i in seq_along(tb)) {
      if (length(tb[[i]])) {
        y = cumsum(tb[[i]])
        grid::grid.rect(i, y, height = tb[[i]], width = 0.8,
                        default.units = "native", just = "top",
                        gp = grid::gpar(col = NA, fill = type_col[names(tb[[i]])]))
      }
    }
    breaks = grid::grid.pretty(c(0, max_count))
    grid::grid.yaxis(at = breaks, label = breaks, gp = grid::gpar(fontsize = 10))
    grid::upViewport()
  }

  ha_column_bar = ComplexHeatmap::HeatmapAnnotation(column_bar = anno_column_bar, which = "column")

  ##Following two funcs add grids
  add_oncoprint = function(type, x, y, width, height) {
    grid::grid.rect(x, y, width - unit(0.5, "mm"),
                    height - grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = bg))

    for (i in 1:length(variant.classes)) {
      if (any(type %in% variant.classes[i])) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = type_col[variant.classes[i]]))
      } else if (any(type %in% 'Amp')) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = bg))
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          unit(15, 'mm'), gp = grid::gpar(col = NA, fill = type_col['Amp']))
      } else if (any(type %in% 'Del')) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = bg))
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height - grid::unit(15, "mm")
                        , gp = grid::gpar(col = NA, fill = type_col['Del']))
      }
    }
  }

  add_oncoprint2 = function(type, x, y, width, height) {
    for (i in 1:length(variant.classes)) {
      if (any(type %in% variant.classes[i])) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = type_col[variant.classes[i]]))
      } else if (any(type %in% 'Amp')) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          unit(15, 'mm'), gp = grid::gpar(col = NA, fill = type_col['Amp']))
      } else if (any(type %in% 'Del')) {

        grid::grid.rect(x, y, width - unit(0.5, "mm"), height - grid::unit(15, "mm")
                        , gp = grid::gpar(col = NA, fill = type_col['Del']))
      }
    }
  }

  #This is the main cel function which is passed to ComplexHeatmap::Hetamap()
  celFun = function(j, i, x, y, width, height, fill) {
    type = mat[i, j]
    if(type != 'xxx'){
      typeList = sort(unlist(strsplit(x = as.character(type), split = ';')), decreasing = TRUE)
      if(length(typeList) > 1){
        for(i in 1:length(typeList)){
          add_oncoprint2(typeList[i], x, y, width, height)
        }
      }else{
        for(i in 1:length(typeList)){
          add_oncoprint(typeList[i], x, y, width, height)
        }
      }

    }else{
      add_oncoprint(type, x, y, width, height)
    }
  }


  #----------------------------------------------------------------------------------------


  if(drawColBar){
    if(is.null(annotation)){

      ht = ComplexHeatmap::Heatmap(mat, na_col = bg,rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
                                   row_names_gp = grid::gpar(fontsize = fontSize), show_column_names = showTumorSampleBarcodes,
                                   show_heatmap_legend = FALSE, top_annotation = ha_column_bar,
                                   top_annotation_height = grid::unit(2, "cm"))
    } else{

      ht = ComplexHeatmap::Heatmap(mat, na_col = bg,rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
                                   row_names_gp = grid::gpar(fontsize = fontSize), show_column_names = showTumorSampleBarcodes,
                                   show_heatmap_legend = FALSE, top_annotation = ha_column_bar,
                                   top_annotation_height = grid::unit(2, "cm"), bottom_annotation = bot.anno)
    }

  } else{

    if(is.null(annotation)){

      ht = ComplexHeatmap::Heatmap(mat, na_col = bg, rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
                                   row_names_gp = grid::gpar(fontsize = fontSize), show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE)
    }else{
      ht = ComplexHeatmap::Heatmap(mat, na_col = bg, rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
                                   row_names_gp = grid::gpar(fontsize = fontSize), show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE, bottom_annotation = bot.anno)
    }
  }

  ha_pct = ComplexHeatmap::HeatmapAnnotation(pct = anno_pct,
                                             width = grid::grobWidth(grid::textGrob("100%", gp = grid::gpar(fontsize = 10))),
                                             which = "row")
  ht_list = ha_pct + ht


  if(drawRowBar){
    ht_list =  ht_list + ha_row_bar
  }

  legend = grid::legendGrob(labels = vc.type_name[names(vc.type_col)],  pch = 15, gp = grid::gpar(col = vc.type_col), nrow = 2)

  suppressWarnings( ComplexHeatmap::draw(ht_list, newpage = FALSE, annotation_legend_side = "bottom", annotation_legend_list = list(legend)) )
}
