#' Plot gistic results.
#' @description takes output generated by readGistic and draws a plot similar to oncoplot.
#'
#' @details
#' Takes gistic file as input and plots it as a matrix. Any desired annotations can be added at the bottom of the oncoplot by providing \code{annotation}
#'
#' @param gistic an \code{\link{GISTIC}} object generated by \code{\link{readGistic}}
#' @param top how many top cytobands to be drawn. defaults to all.
#' @param showTumorSampleBarcodes logical to include sample names.
#' @param annotation data.frame with first column containing Tumor_Sample_Barcodes and rest of columns with annotations.
#' @param bandsToIgnore do not show these bands in the plot Default NULL.
#' @param removeNonAltered Logical. If \code{TRUE} removes samples with no mutations in the oncoplot for better visualization. Default \code{FALSE}.
#' @param colors named vector of colors Amp and Del events.
#' @param fontSize font size for cytoband names. Default 10.
#' @return None.
#' @examples
#' all.lesions <- system.file("extdata", "all_lesions.conf_99.txt", package = "maftools")
#' amp.genes <- system.file("extdata", "amp_genes.conf_99.txt", package = "maftools")
#' del.genes <- system.file("extdata", "del_genes.conf_99.txt", package = "maftools")
#' gistic.summary = readGistic(gisticAllLesionsFile = all.lesions, gisticAmpGenesFile = amp.genes, gisticDelGenesFile = del.genes, isTCGA = TRUE)
#' gisticPlot(gistic.summary)
#' @import ComplexHeatmap
#' @import grid
#' @seealso \code{\link{oncostrip}}
#' @export


gisticPlot = function (gistic, top = NULL,
                     showTumorSampleBarcodes = FALSE, annotation = NULL, bandsToIgnore = NULL,
                     removeNonAltered = FALSE, colors = NULL, fontSize = 10) {

  #set seed for consistancy.
  set.seed(seed = 1024)

  #Not so useful. Set default to FALSE.
  drawRowBar = FALSE
  drawColBar = FALSE
  writeMatrix = FALSE


  numMat = gistic@numericMatrix
  rownames(numMat) = sapply(strsplit(x = rownames(numMat), split = ':'), '[', 2)
  mat_origin = gistic@cnMatrix
  rownames(mat_origin) = sapply(strsplit(x = rownames(mat_origin), split = ':'), '[', 2)

  if(ncol(numMat) < 2){
    stop('Cannot create plot for single sample. Minimum two sample required ! ')
  }

  #remove genes from bandsToIgnore if any
  if(!is.null(bandsToIgnore)){
    mat_origin = mat_origin[!rownames(mat_origin) %in% bandsToIgnore,]
  }

  #choose user defined nuber of top genes
  if(is.null(top)){
    mat = mat_origin
  }else{
    if(nrow(mat_origin) < top){
      mat = mat_origin
    }else{
      mat = mat_origin[1:top, ]
    }
  }

  #annotation if given
  if(!is.null(annotation)){
    annotation[,1] = gsub(pattern = '-', replacement = '.', x = annotation[,1])
    rownames(annotation) = annotation[,1]
    annotation = annotation[colnames(mat_origin),]
    annotation = annotation[complete.cases(annotation),]
    anno.df = data.frame(row.names = annotation[,1])
    anno.df = cbind(anno.df, annotation[,2:ncol(annotation)])
    colnames(anno.df) = colnames(annotation)[2:ncol(annotation)]
    bot.anno = HeatmapAnnotation(anno.df)
  }

  if (writeMatrix) {
    write.table(mat_origin, "onco_matrix.txt", sep = "\t", quote = FALSE)
  }

  oncoPlot = TRUE #Change later
  bg = "#CCCCCC" #Default gray background

  #To remove samples with no mutations in top n genes, if user says removeNonAltered
  if(removeNonAltered){
    numMat = numMat[rownames(mat),]
    numMat = numMat[,colnames(mat)]
    tsb = colnames(numMat)
    tsb.exclude = colnames(numMat[,colSums(numMat) == 0])
    tsb.include = tsb[!tsb %in% tsb.exclude]
    mat = mat[,tsb.include]
  }

  mat[mat == ''] = 'xxx'

  #hard coded colors for variant classification if user doesnt provide any
  if(is.null(colors)){
    col = c('green', 'red', 'blue')
    names(col) = names = c('Del', 'Amp', 'Complex')
  }else{
    col = colors
  }

  variant.classes = unique(unlist(as.list(apply(mat_origin, 2, unique))))
  variant.classes = unique(unlist(strsplit(x = variant.classes, split = ';', fixed = TRUE)))
  variant.classes = variant.classes[!variant.classes %in% c('xxx')]

  type_col = structure(col[variant.classes], names = names(col[variant.classes]))
  type_col = type_col[!is.na(type_col)]

  type_name = structure(variant.classes, names = variant.classes)


  #------------------------------------Helper functions to add %, rowbar and colbar----------------------------------------------------

  ##This function adds percent rate
  anno_pct = function(index) {
    n = length(index)
    pct = apply(mat_origin[rev(index), ], 1, function(x) sum(!grepl("^\\s*$", x))/length(x)) * 100
    pct = paste0(round(pct), "%")
    grid::pushViewport(viewport(xscale = c(0, 1), yscale = c(0.5, n + 0.5)))
    grid::grid.text(pct, x = 1, y = seq_along(index), default.units = "native",
                    just = "right", gp = grid::gpar(fontsize = fontSize))
    grid::upViewport()
  }

  ha_pct = ComplexHeatmap::HeatmapAnnotation(pct = anno_pct,
                                             width = grid::grobWidth(grid::textGrob("100%", gp = grid::gpar(fontsize = 10))), which = "row")

  ##Following two funcs add grids
  add_oncoprint = function(type, x, y, width, height) {
    grid::grid.rect(x, y, width - unit(0.5, "mm"),
                    height - grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = bg))

    for (i in 1:length(variant.classes)) {
      if (any(type %in% variant.classes[i])) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = type_col[variant.classes[i]]))
      }
    }
  }

#   add_oncoprint2 = function(type, x, y, width, height) {
#     for (i in 1:length(variant.classes)) {
#       if (any(type %in% variant.classes[i])) {
#         grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
#                           grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = type_col[variant.classes[i]]))
#       } else if (any(type %in% 'Amp')) {
#         grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
#                           unit(15, 'mm'), gp = grid::gpar(col = NA, fill = type_col['Amp']))
#       } else if (any(type %in% 'Del')) {
#
#         grid::grid.rect(x, y, width - unit(0.5, "mm"), height - grid::unit(15, "mm")
#                         , gp = grid::gpar(col = NA, fill = type_col['Del']))
#       }
#     }
#   }

  #This is the main cel function which is passed to ComplexHeatmap::Hetamap()
  celFun = function(j, i, x, y, width, height, fill) {
    type = mat[i, j]
    if(type != 'xxx'){
      typeList = unlist(strsplit(x = as.character(type), split = ';'))
      if(length(typeList) > 1){
        for(i in 1:length(typeList)){
          add_oncoprint(typeList[i], x, y, width, height)
        }
      }else{
        for(i in 1:length(typeList)){
          add_oncoprint(typeList[i], x, y, width, height)
        }
      }

    }else{
      add_oncoprint(type, x, y, width, height)
    }
  }

  #---------------------------------------------------------------------------

      if(is.null(annotation)){
        ht = ComplexHeatmap::Heatmap(mat, rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
          row_names_gp = grid::gpar(fontsize = fontSize),
          show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE)
      }else{
        ht = ComplexHeatmap::Heatmap(mat, rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
          row_names_gp = grid::gpar(fontsize = fontSize),
          show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE,
          bottom_annotation = bot.anno)
      }


    ht_list = ha_pct + ht

    legend = grid::legendGrob(labels = type_name[names(type_col)],  pch = 15, gp = grid::gpar(col = type_col), nrow = 2)

    ComplexHeatmap::draw(ht_list, newpage = FALSE, annotation_legend_side = "bottom", annotation_legend_list = list(legend))
}
